#!/usr/bin/env bash
#
# gt-bmad-workflow - Track BMAD workflows as Gas Town beads
#
# Converts BMAD workflow directories to Gas Town formulas and manages
# workflow execution state as molecules instead of frontmatter.
#
set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
GT_BMAD_ROOT="${GT_BMAD_ROOT:-$(cd "$SCRIPT_DIR/.." && pwd)}"

# BMAD workflow locations (in priority order)
# Note: Globs are expanded at runtime in get_workflow_paths()
BMAD_WORKFLOW_PATH_PATTERNS=(
    "$GT_BMAD_ROOT/bmad/src/core/workflows"
    "$GT_BMAD_ROOT/bmad/src/modules/bmm/workflows"
    "$GT_BMAD_ROOT/bmad/src/modules/bmb/workflows"
    "$GT_BMAD_ROOT/bmad/src/modules/cis/workflows"
    # Also check in polecat worktrees
    "$GT_BMAD_ROOT/bmad/polecats/*/bmad/src/core/workflows"
    "$GT_BMAD_ROOT/bmad/polecats/*/bmad/src/modules/bmm/workflows"
)

# Expand glob patterns to actual paths
get_workflow_paths() {
    local paths=()
    for pattern in "${BMAD_WORKFLOW_PATH_PATTERNS[@]}"; do
        # Use compgen to safely expand globs
        while IFS= read -r path; do
            [[ -d "$path" ]] && paths+=("$path")
        done < <(compgen -G "$pattern" 2>/dev/null || true)
        # Also add non-glob paths directly if they exist
        if [[ "$pattern" != *'*'* && -d "$pattern" ]]; then
            paths+=("$pattern")
        fi
    done
    printf '%s\n' "${paths[@]}" | sort -u
}

# Formula output location
FORMULA_OUTPUT_DIR="$GT_BMAD_ROOT/.beads/formulas"

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[0;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
NC='\033[0m'

error() { echo -e "${RED}error:${NC} $1" >&2; exit 1; }
info() { echo -e "${BLUE}info:${NC} $1"; }
success() { echo -e "${GREEN}âœ“${NC} $1"; }
warn() { echo -e "${YELLOW}warning:${NC} $1"; }

usage() {
    cat <<EOF
gt-bmad-workflow - Track BMAD workflows as Gas Town beads

Usage: gt-bmad-workflow <command> [options]

Agent Dispatch:
  dispatch <agent> <trigger>  Execute workflow by agent menu trigger
  triggers [agent]            List agent triggers (all or specific)

Workflow Management:
  list                    List available BMAD workflows
  generate <workflow>     Generate Gas Town formula from BMAD workflow
  start <workflow>        Start a tracked workflow (pour molecule)
  auto-start <workflow>   Auto-generate formula, pour molecule, and create step beads
  status [mol-id]         Show current workflow progress
  step <mol-id>           Mark current step complete and show next
  close <mol-id>          Complete the workflow

Runtime Integration (call from within workflows):
  step-done <step-id>     Mark a step complete (used by BMAD workflows)
  context                 Show current molecule context (if any)
  continue <workflow>     Check for continuable session via beads
  apc-menu [context]      Present standard A/P/C menu and wait for selection

Examples:
  # Agent dispatch (recommended)
  gt-bmad-workflow dispatch dev DS        # Run dev-story workflow
  gt-bmad-workflow dispatch analyst BP    # Run brainstorm-project
  gt-bmad-workflow triggers dev           # Show dev agent's triggers

  # Workflow management
  gt-bmad-workflow list
  gt-bmad-workflow generate brainstorming
  gt-bmad-workflow start brainstorming
  gt-bmad-workflow auto-start brainstorming  # Full auto-setup with step beads
  gt-bmad-workflow status bmad-mol-12345

  # From within a running workflow:
  gt-bmad-workflow step-done step-01-session-setup
  gt-bmad-workflow context
  gt-bmad-workflow continue brainstorming

Integration:
  Workflows tracked as beads enable:
  - Cross-session continuity without frontmatter
  - Central monitoring via bd mol status
  - Handoffs between agents
  - Progress queries (bd mol progress <id>)
  - Automatic step bead creation with dependencies

Environment Variables:
  BMAD_MOLECULE_ID    Set automatically when workflow starts via this tool
  BMAD_WORKFLOW_NAME  The workflow name being executed
EOF
}

# Find workflow directory by name
find_workflow() {
    local name="$1"

    # Check each search path
    while IFS= read -r base_path; do
        [[ -z "$base_path" ]] && continue

        # Direct match
        if [[ -d "$base_path/$name" ]]; then
            echo "$base_path/$name"
            return 0
        fi
        # Check subdirectories (for phase-organized workflows like 1-analysis/, 2-plan-workflows/)
        for subdir in "$base_path"/*/"$name"; do
            if [[ -d "$subdir" ]]; then
                echo "$subdir"
                return 0
            fi
        done
    done < <(get_workflow_paths)

    return 1
}

# List all available BMAD workflows
cmd_list() {
    echo -e "${CYAN}ðŸ“‹ Available BMAD Workflows${NC}"
    echo ""

    local found=0
    local seen_workflows=""

    while IFS= read -r base_path; do
        [[ -z "$base_path" ]] && continue

        # Find workflow directories (those with workflow.md or steps/)
        while IFS= read -r -d '' workflow_dir; do
            local workflow_name=$(basename "$workflow_dir")

            # Skip if already seen (avoid duplicates from multiple worktrees)
            if [[ "$seen_workflows" == *"|$workflow_name|"* ]]; then
                continue
            fi
            seen_workflows="$seen_workflows|$workflow_name|"

            local workflow_md="$workflow_dir/workflow.md"
            local workflow_yaml="$workflow_dir/workflow.yaml"

            # Skip if not a workflow directory
            [[ -f "$workflow_md" || -f "$workflow_yaml" || -d "$workflow_dir/steps" ]] || continue

            # Get description
            local desc=""
            if [[ -f "$workflow_md" ]]; then
                # Extract description from frontmatter or first paragraph
                desc=$(grep -m1 "^description:" "$workflow_md" 2>/dev/null | sed 's/description:\s*//' | head -c 60)
                if [[ -z "$desc" ]]; then
                    desc=$(grep -m1 "^\*\*Goal:\*\*" "$workflow_md" 2>/dev/null | sed 's/\*\*Goal:\*\*\s*//' | head -c 60)
                fi
            elif [[ -f "$workflow_yaml" ]]; then
                desc=$(grep -m1 "^description:" "$workflow_yaml" 2>/dev/null | sed 's/description:\s*//' | sed 's/^["'"'"']//' | sed 's/["'"'"']$//' | head -c 60)
            fi

            # Check if formula exists
            local formula_status=""
            if [[ -f "$FORMULA_OUTPUT_DIR/bmad-$workflow_name.formula.toml" ]]; then
                formula_status="${GREEN}[formula]${NC}"
            fi

            printf "  %-25s %s %s\n" "$workflow_name" "$formula_status" "$desc"
            found=$((found + 1))
        done < <(find "$base_path" -mindepth 1 -maxdepth 2 -type d -print0 2>/dev/null)
    done < <(get_workflow_paths)

    if [[ $found -eq 0 ]]; then
        echo "  (no workflows found)"
    fi

    echo ""
    echo "Use 'gt-bmad-workflow generate <name>' to create a formula for bead tracking."
}

# Extract step files from workflow directory
get_step_files() {
    local workflow_dir="$1"
    local steps_dir="$workflow_dir/steps"

    if [[ ! -d "$steps_dir" ]]; then
        return 1
    fi

    # List step files in order
    ls -1 "$steps_dir"/step-*.md 2>/dev/null | sort
}

# Parse step file to extract metadata
parse_step() {
    local step_file="$1"
    local filename=$(basename "$step_file")

    # Extract step ID from filename (e.g., step-01-session-setup.md -> session-setup)
    local step_id=$(echo "$filename" | sed 's/^step-[0-9]*[a-z]*-//' | sed 's/\.md$//')

    # Get step number and variant
    local step_num=$(echo "$filename" | grep -oE 'step-[0-9]+' | sed 's/step-//')
    local step_variant=$(echo "$filename" | grep -oE 'step-[0-9]+[a-z]' | sed 's/step-[0-9]*//')

    # Extract title from first # heading
    local title=$(grep -m1 "^# " "$step_file" | sed 's/^# //')

    # Extract task from ## YOUR TASK: section
    local task=$(awk '/^## YOUR TASK:/,/^##/' "$step_file" | grep -v "^##" | head -5 | tr '\n' ' ' | sed 's/^[[:space:]]*//' | head -c 200)

    echo "$step_id|$step_num|$step_variant|$title|$task"
}

# Generate a Gas Town formula from BMAD workflow
cmd_generate() {
    local workflow_name="$1"

    if [[ -z "$workflow_name" ]]; then
        error "Usage: gt-bmad-workflow generate <workflow-name>"
    fi

    local workflow_dir
    workflow_dir=$(find_workflow "$workflow_name") || error "Workflow not found: $workflow_name"

    info "Generating formula from: $workflow_dir"

    # Read workflow metadata
    local workflow_md="$workflow_dir/workflow.md"
    local workflow_yaml="$workflow_dir/workflow.yaml"
    local description=""
    local goal=""

    if [[ -f "$workflow_md" ]]; then
        # Extract description directly from workflow.md (frontmatter or body)
        description=$(grep -m1 "^description:" "$workflow_md" | sed 's/description:\s*//' | sed "s/^['\"]//;s/['\"]$//")
        goal=$(grep -m1 "^\*\*Goal:\*\*" "$workflow_md" | sed 's/\*\*Goal:\*\*//' | sed 's/^[[:space:]]*//')
        if [[ -z "$description" && -n "$goal" ]]; then
            description="$goal"
        fi
    elif [[ -f "$workflow_yaml" ]]; then
        description=$(grep "^description:" "$workflow_yaml" | sed 's/description:\s*//' | sed "s/^['\"]//;s/['\"]$//")
    fi

    [[ -z "$description" ]] && description="BMAD $workflow_name workflow"

    # Collect steps in first pass to build step ID map
    local steps_info=()
    local step_id_map=()  # Maps step numbers to full step IDs
    local prev_main_step=""  # Previous non-variant step's full ID

    # First pass: collect all step info
    local temp_steps=()
    while IFS= read -r step_file; do
        [[ -z "$step_file" ]] && continue

        local parsed
        parsed=$(parse_step "$step_file")

        local step_id step_num step_variant title task
        IFS='|' read -r step_id step_num step_variant title task <<< "$parsed"

        # Skip continuation steps (step-01b-continue.md)
        if [[ "$step_id" == "continue" ]]; then
            continue
        fi

        # Build full step ID
        local full_step_id="step-$step_num"
        if [[ -n "$step_variant" ]]; then
            full_step_id="step-$step_num$step_variant-$step_id"
        else
            full_step_id="step-$step_num-$step_id"
            # Record mapping for this step number
            step_id_map[$step_num]="$full_step_id"
        fi

        temp_steps+=("$step_id|$step_num|$step_variant|$title|$task|$full_step_id")
    done < <(get_step_files "$workflow_dir")

    # Second pass: resolve dependencies
    prev_main_step=""
    for step_info in "${temp_steps[@]}"; do
        local step_id step_num step_variant title task full_step_id
        IFS='|' read -r step_id step_num step_variant title task full_step_id <<< "$step_info"

        # Determine dependency
        local needs=""
        if [[ -n "$step_variant" ]]; then
            # Variant step - depends on the main step from previous number
            local base_num=$((10#$step_num - 1))
            if [[ $base_num -gt 0 ]]; then
                needs="${step_id_map[$base_num]}"
            fi
        elif [[ -n "$prev_main_step" ]]; then
            # Main step depends on previous main step
            needs="$prev_main_step"
        fi

        steps_info+=("$step_id|$step_num|$step_variant|$title|$task|$needs|$full_step_id")

        # Track previous main step for non-variant steps
        if [[ -z "$step_variant" ]]; then
            prev_main_step="$full_step_id"
        fi
    done

    if [[ ${#steps_info[@]} -eq 0 ]]; then
        error "No step files found in workflow: $workflow_name"
    fi

    # Generate formula TOML
    local formula_file="$FORMULA_OUTPUT_DIR/bmad-$workflow_name.formula.toml"
    mkdir -p "$FORMULA_OUTPUT_DIR"

    cat > "$formula_file" <<EOF
# Auto-generated from BMAD workflow: $workflow_name
# Source: $workflow_dir
# Generated: $(date -Iseconds)

description = """
$description

## BMAD Workflow Integration

This formula was auto-generated from a BMAD workflow. It enables:
- Bead-based state tracking (instead of frontmatter)
- Cross-session continuity via molecules
- Central monitoring via Gas Town

## Original Workflow Location
$workflow_dir

## Usage
1. Start the workflow: gt-bmad-workflow start $workflow_name
2. Work through steps using bd ready / bd close <step>
3. Or use the original BMAD workflow for full interactive experience
"""
formula = "bmad-$workflow_name"
version = 1

EOF

    # Add steps
    for step_info in "${steps_info[@]}"; do
        local step_id step_num step_variant title task needs full_step_id
        IFS='|' read -r step_id step_num step_variant title task needs full_step_id <<< "$step_info"

        # Escape for TOML
        title=$(echo "$title" | sed 's/"/\\"/g')
        task=$(echo "$task" | sed 's/"/\\"/g' | sed 's/$/\\n/' | tr -d '\n')

        cat >> "$formula_file" <<EOF
[[steps]]
id = "$full_step_id"
title = "$title"
EOF

        if [[ -n "$needs" ]]; then
            cat >> "$formula_file" <<EOF
needs = ["$needs"]
EOF
        fi

        cat >> "$formula_file" <<EOF
description = """
$task

**Source step file:** $workflow_dir/steps/step-$step_num$step_variant-$step_id.md

Load and follow the original BMAD step file for full instructions.
Mark this step complete when done: bd close <this-step-id>
"""

EOF
    done

    # Add variables section
    cat >> "$formula_file" <<EOF
[vars]
[vars.output_file]
description = "Path to the output document for this workflow session"
required = false
default = ""

[vars.context_file]
description = "Optional context file for project-specific guidance"
required = false
default = ""
EOF

    success "Generated formula: $formula_file"
    echo ""
    echo "Steps found: ${#steps_info[@]}"
    echo ""
    echo "Next steps:"
    echo "  1. Review the formula: cat $formula_file"
    echo "  2. Start a tracked workflow: gt-bmad-workflow start $workflow_name"
    echo "  3. Or use bd formula show bmad-$workflow_name"
}

# Infer dependency type from step structure
infer_dependency_type() {
    local step_file="$1"

    if [[ ! -f "$step_file" ]]; then
        echo "blocks"
        return 0
    fi

    local step_content=$(cat "$step_file" 2>/dev/null || echo "")

    # Check for parallel execution hints
    if echo "$step_content" | grep -qi "parallel\|concurrent\|simultaneously"; then
        echo "tracks"
    else
        echo "blocks"
    fi
}

# Create workflow step beads with automatic dependencies
create_workflow_step_beads() {
    local workflow_name="$1"
    local mol_id="$2"
    local workflow_dir="$3"

    info "Creating workflow step beads with dependencies..."

    # Find all step files (step-01-*.md, step-02-*.md, etc.)
    local step_files=()
    while IFS= read -r step_file; do
        [[ -z "$step_file" ]] && continue
        # Skip continuation steps (step-01b-continue.md)
        if ! basename "$step_file" | grep -q "continue.md$"; then
            step_files+=("$step_file")
        fi
    done < <(get_step_files "$workflow_dir")

    if [[ ${#step_files[@]} -eq 0 ]]; then
        warn "No step files found in workflow: $workflow_name"
        return 1
    fi

    # First pass: create all step beads and collect IDs
    declare -A step_ids
    local prev_step_id=""
    local step_count=0

    for step_file in "${step_files[@]}"; do
        # Extract step number and title
        local step_num=$(basename "$step_file" | sed -E 's/step-([0-9]+).*/\1/')
        local step_title=$(grep -m1 "^# " "$step_file" | sed 's/^# //' || echo "Step $step_num")

        # Create bead for this step
        info "Creating step bead: $step_title"
        local step_id
        if step_id=$(bd create "$step_title" \
            --type task \
            --parent "$mol_id" \
            --label "step:$step_num" \
            --label "workflow:$workflow_name" \
            --json 2>/dev/null | jq -r '.id' 2>/dev/null); then

            if [[ -n "$step_id" && "$step_id" != "null" ]]; then
                step_ids[$step_num]="$step_id"
                step_count=$((step_count + 1))

                # Add dependency on previous step (blocks relationship)
                if [[ -n "$prev_step_id" ]]; then
                    local dep_type=$(infer_dependency_type "$step_file")
                    if bd dep add "$step_id" "$prev_step_id" --type "$dep_type" 2>/dev/null; then
                        info "  Added dependency: step-$step_num depends on previous ($dep_type)"
                    else
                        # Try without --type flag (older bd versions)
                        bd dep add "$step_id" "$prev_step_id" 2>/dev/null || warn "  Could not add dependency"
                    fi
                fi

                prev_step_id="$step_id"
            else
                warn "Failed to create step bead for: $step_title"
            fi
        else
            warn "Failed to create step bead for: $step_title"
        fi
    done

    success "Created $step_count workflow step beads"
    return 0
}

# Start a tracked workflow (pour molecule)
cmd_start() {
    local workflow_name="$1"
    shift || true

    if [[ -z "$workflow_name" ]]; then
        error "Usage: gt-bmad-workflow start <workflow-name> [--var key=value ...]"
    fi

    local formula_name="bmad-$workflow_name"
    local formula_file="$FORMULA_OUTPUT_DIR/$formula_name.formula.toml"

    # Check if formula exists, generate if not
    if [[ ! -f "$formula_file" ]]; then
        warn "Formula not found, generating..."
        cmd_generate "$workflow_name"
    fi

    info "Starting tracked workflow: $workflow_name"

    # Pour the molecule (need direct DB access for pour)
    local pour_output
    if pour_output=$(bd --no-daemon mol pour "$formula_name" "$@" 2>&1); then
        success "Workflow molecule created"
        echo "$pour_output"

        # Extract molecule ID from output (pattern: hq-mol-xxx or gt-xxx)
        local mol_id
        mol_id=$(echo "$pour_output" | grep -oE '(hq-mol-[a-z0-9]+|gt-[a-z0-9]+)' | head -1)

        if [[ -n "$mol_id" ]]; then
            # Save context for runtime integration
            save_context "$mol_id" "$workflow_name"

            echo ""
            echo "Workflow tracking active:"
            echo "  Molecule ID: $mol_id"
            echo "  View progress: bd mol progress $mol_id"
            echo "  Find next step: bd ready"
            echo "  Complete step: gt-bmad-workflow step-done <step-id>"
            echo ""
            echo "For runtime integration, set these environment variables:"
            echo "  export BMAD_MOLECULE_ID=$mol_id"
            echo "  export BMAD_WORKFLOW_NAME=$workflow_name"
            echo ""
            echo "Or use context-aware commands:"
            echo "  gt-bmad-workflow context     # Show current workflow"
            echo "  gt-bmad-workflow step-done   # Mark step complete"
        fi
    else
        error "Failed to pour molecule: $pour_output"
    fi
}

# Auto-start workflow: generate formula + pour molecule + create step beads
cmd_auto_start() {
    local workflow_name="$1"
    shift || true

    if [[ -z "$workflow_name" ]]; then
        error "Usage: gt-bmad-workflow auto-start <workflow-name> [--var key=value ...]"
    fi

    local workflow_dir
    workflow_dir=$(find_workflow "$workflow_name") || error "Workflow not found: $workflow_name"

    info "Auto-starting workflow: $workflow_name"

    # Step 1: Generate formula if not exists
    local formula_file="$FORMULA_OUTPUT_DIR/bmad-$workflow_name.formula.toml"
    if [[ ! -f "$formula_file" ]]; then
        info "Generating formula for $workflow_name..."
        cmd_generate "$workflow_name"
    else
        info "Formula already exists: $formula_file"
    fi

    # Step 2: Pour molecule
    info "Creating molecule for $workflow_name..."
    local formula_name="bmad-$workflow_name"
    local pour_output
    if pour_output=$(bd --no-daemon mol pour "$formula_name" "$@" 2>&1); then
        success "Workflow molecule created"

        # Extract molecule ID from output
        local mol_id
        mol_id=$(echo "$pour_output" | grep -oE '(hq-mol-[a-z0-9]+|gt-[a-z0-9]+|bmad-mol-[a-z0-9]+)' | head -1)

        if [[ -n "$mol_id" ]]; then
            # Save context for runtime integration
            save_context "$mol_id" "$workflow_name"

            # Step 3: Create step beads with dependencies
            info "Creating workflow step beads..."
            if create_workflow_step_beads "$workflow_name" "$mol_id" "$workflow_dir"; then
                success "Workflow step beads created successfully"
            else
                warn "Some step beads could not be created"
            fi

            # Export context for polecat
            export BMAD_MOLECULE_ID="$mol_id"
            export BMAD_WORKFLOW_NAME="$workflow_name"

            echo ""
            success "Workflow $workflow_name ready (molecule: $mol_id)"
            echo ""
            echo "Workflow tracking active:"
            echo "  Molecule ID: $mol_id"
            echo "  Workflow: $workflow_name"
            echo ""
            echo "Essential commands:"
            echo "  bd ready --mol $mol_id              # Show next available tasks"
            echo "  bd show <task-id>                    # View task details"
            echo "  bd update <task-id> --status in_progress  # Start work"
            echo "  bd close <task-id>                   # Complete work"
            echo ""
            echo "Spawn polecat with workflow context:"
            echo "  gt-bmad-spawn <agent> --mol $mol_id"
            echo ""
            echo "Or set environment variables manually:"
            echo "  export BMAD_MOLECULE_ID=$mol_id"
            echo "  export BMAD_WORKFLOW_NAME=$workflow_name"
        else
            error "Could not extract molecule ID from pour output"
        fi
    else
        error "Failed to pour molecule: $pour_output"
    fi
}

# Show workflow status
cmd_status() {
    local mol_id="$1"

    if [[ -z "$mol_id" ]]; then
        # Show all active BMAD workflows
        info "Active BMAD workflow molecules:"
        bd --no-daemon mol progress 2>/dev/null | grep -E "bmad-" || echo "  (no active BMAD workflows)"
    else
        bd --no-daemon mol progress "$mol_id"
    fi
}

# Mark step complete and show next
cmd_step() {
    local mol_id="$1"

    if [[ -z "$mol_id" ]]; then
        error "Usage: gt-bmad-workflow step <mol-id>"
    fi

    # Show current step
    info "Current position in workflow:"
    bd --no-daemon mol current "$mol_id"

    echo ""
    echo "Ready steps:"
    bd --no-daemon ready 2>/dev/null | head -10

    echo ""
    echo "To complete a step: bd close <step-id>"
}

# Close workflow
cmd_close() {
    local mol_id="$1"

    if [[ -z "$mol_id" ]]; then
        error "Usage: gt-bmad-workflow close <mol-id>"
    fi

    info "Squashing workflow molecule: $mol_id"
    bd --no-daemon mol squash "$mol_id"
}

# Context file location
get_context_file() {
    echo "$GT_BMAD_ROOT/.runtime/workflow-context.json"
}

# Save workflow context for runtime integration
save_context() {
    local mol_id="$1"
    local workflow_name="$2"
    local context_file
    context_file=$(get_context_file)

    mkdir -p "$(dirname "$context_file")"

    cat > "$context_file" <<EOF
{
  "molecule_id": "$mol_id",
  "workflow_name": "$workflow_name",
  "started_at": "$(date -Iseconds)"
}
EOF
}

# Load workflow context
load_context() {
    local context_file
    context_file=$(get_context_file)

    if [[ -f "$context_file" ]]; then
        cat "$context_file"
    else
        echo "{}"
    fi
}

# Clear workflow context
clear_context() {
    local context_file
    context_file=$(get_context_file)
    rm -f "$context_file"
}

# Get molecule ID from context or environment
get_molecule_id() {
    # First check environment variable
    if [[ -n "${BMAD_MOLECULE_ID:-}" ]]; then
        echo "$BMAD_MOLECULE_ID"
        return 0
    fi

    # Fall back to context file
    local context_file
    context_file=$(get_context_file)

    if [[ -f "$context_file" ]]; then
        local mol_id
        mol_id=$(grep -oE '"molecule_id":\s*"[^"]+"' "$context_file" | sed 's/"molecule_id":\s*"//' | sed 's/"$//')
        if [[ -n "$mol_id" ]]; then
            echo "$mol_id"
            return 0
        fi
    fi

    return 1
}

# Runtime: Mark step complete (called from within workflow execution)
cmd_step_done() {
    local step_id="$1"

    if [[ -z "$step_id" ]]; then
        error "Usage: gt-bmad-workflow step-done <step-id>"
    fi

    # Get molecule context
    local mol_id
    if ! mol_id=$(get_molecule_id); then
        warn "No molecule context found - step completion not tracked in beads"
        warn "Hint: Start workflow with 'gt-bmad-workflow start <name>' for bead tracking"
        return 0
    fi

    info "Marking step complete: $step_id (molecule: $mol_id)"

    # Find the step bead ID
    local step_bead_id
    step_bead_id=$(bd --no-daemon search "$step_id" 2>/dev/null | grep -E "hq-mol-|bmad-" | head -1 | awk '{print $1}')

    if [[ -z "$step_bead_id" ]]; then
        # Try to find by title match
        step_bead_id=$(bd --no-daemon list 2>/dev/null | grep -i "$step_id" | head -1 | awk '{print $1}')
    fi

    if [[ -n "$step_bead_id" ]]; then
        if bd --no-daemon close "$step_bead_id" 2>/dev/null; then
            success "Step bead closed: $step_bead_id"
        else
            warn "Could not close step bead: $step_bead_id"
        fi
    else
        warn "Step bead not found for: $step_id"
    fi
}

# Runtime: Show current molecule context
cmd_context() {
    local mol_id
    if mol_id=$(get_molecule_id); then
        echo -e "${CYAN}ðŸ“Ž Workflow Context${NC}"
        echo ""
        echo "Molecule ID: $mol_id"

        local context_file
        context_file=$(get_context_file)
        if [[ -f "$context_file" ]]; then
            local workflow_name started_at
            workflow_name=$(grep -oE '"workflow_name":\s*"[^"]+"' "$context_file" | sed 's/"workflow_name":\s*"//' | sed 's/"$//')
            started_at=$(grep -oE '"started_at":\s*"[^"]+"' "$context_file" | sed 's/"started_at":\s*"//' | sed 's/"$//')
            echo "Workflow: $workflow_name"
            echo "Started: $started_at"
        fi

        echo ""
        echo "Progress:"
        bd --no-daemon mol progress "$mol_id" 2>/dev/null || echo "  (could not fetch progress)"
    else
        echo -e "${YELLOW}No active workflow context${NC}"
        echo ""
        echo "Start a workflow with: gt-bmad-workflow start <workflow-name>"
    fi
}

# Runtime: Check for continuable workflow session via beads
cmd_continue() {
    local workflow_name="$1"

    if [[ -z "$workflow_name" ]]; then
        error "Usage: gt-bmad-workflow continue <workflow-name>"
    fi

    local formula_name="bmad-$workflow_name"

    info "Checking for continuable session: $workflow_name"

    # Find open molecules for this workflow
    local open_mols
    open_mols=$(bd --no-daemon list --label molecule 2>/dev/null | grep -i "$formula_name" | grep -v "âœ“" || true)

    if [[ -z "$open_mols" ]]; then
        echo "no-session"
        echo "" >&2
        echo "No continuable session found for workflow: $workflow_name" >&2
        echo "Start new session with: gt-bmad-workflow start $workflow_name" >&2
        return 1
    fi

    # Get the most recent open molecule
    local mol_id mol_title
    mol_id=$(echo "$open_mols" | head -1 | awk '{print $1}')
    mol_title=$(echo "$open_mols" | head -1 | sed 's/^[^ ]* //')

    echo "found"
    echo "$mol_id"

    echo "" >&2
    echo -e "${GREEN}âœ“${NC} Found continuable session:" >&2
    echo "  Molecule: $mol_id" >&2
    echo "  Title: $mol_title" >&2
    echo "" >&2
    echo "Progress:" >&2
    bd --no-daemon mol progress "$mol_id" 2>/dev/null | sed 's/^/  /' >&2

    echo "" >&2
    echo "To resume, set environment:" >&2
    echo "  export BMAD_MOLECULE_ID=$mol_id" >&2
    echo "  export BMAD_WORKFLOW_NAME=$workflow_name" >&2

    # Save context for this session
    save_context "$mol_id" "$workflow_name"
    success "Context saved for workflow continuation" >&2
}

# ============================================================================
# Agent Dispatch Functions
# ============================================================================

# BMAD agents directory
BMAD_AGENTS_DIR="$GT_BMAD_ROOT/bmad/mayor/rig/src/modules/bmm/agents"

# Parse YAML field (simple extraction for single-line values)
yaml_get() {
    local file="$1"
    local key="$2"
    grep -E "^\s*${key}:" "$file" 2>/dev/null | head -1 | sed "s/.*${key}:\s*//" | sed 's/^["'"'"']//' | sed 's/["'"'"']$//'
}

# Get agent file path (with fuzzy matching)
get_agent_file() {
    local agent="$1"

    # Exact match first
    local file="$BMAD_AGENTS_DIR/${agent}.agent.yaml"
    if [[ -f "$file" ]]; then
        echo "$file"
        return 0
    fi

    # Fuzzy match
    local agent_lower="${agent,,}"
    for f in "$BMAD_AGENTS_DIR"/*.agent.yaml; do
        [[ -f "$f" ]] || continue
        local base=$(basename "$f" .agent.yaml)
        if [[ "${base,,}" == *"$agent_lower"* ]]; then
            echo "$f"
            return 0
        fi
    done

    return 1
}

# Parse trigger field to extract patterns (e.g., "DS or fuzzy match on dev-story")
parse_trigger_patterns() {
    local trigger_field="$1"
    local patterns=""

    # Extract uppercase short codes (2-4 letters)
    local short_codes
    short_codes=$(echo "$trigger_field" | grep -oE '\b[A-Z]{2,4}\b' || true)
    for code in $short_codes; do
        patterns="$patterns ${code,,}"
    done

    # Extract kebab-case names
    local kebab_names
    kebab_names=$(echo "$trigger_field" | grep -oE '\b[a-z]+-[a-z]+(-[a-z]+)*\b' || true)
    for name in $kebab_names; do
        patterns="$patterns $name"
    done

    echo "$patterns" | xargs
}

# Match trigger to menu item in agent file
match_agent_trigger() {
    local agent_file="$1"
    local trigger="$2"
    local trigger_lower="${trigger,,}"

    # Parse menu items from YAML
    local in_menu=0
    local current_trigger=""
    local current_workflow=""
    local current_description=""
    local matched_workflow=""
    local matched_description=""
    local match_count=0

    while IFS= read -r line; do
        # Detect menu section
        if [[ "$line" =~ ^[[:space:]]*menu: ]]; then
            in_menu=1
            continue
        fi

        # Exit menu section on non-indented non-empty line
        if [[ $in_menu -eq 1 && "$line" =~ ^[^[:space:]] && -n "$line" ]]; then
            in_menu=0
        fi

        [[ $in_menu -eq 0 ]] && continue

        # Parse menu item fields
        if [[ "$line" =~ ^[[:space:]]*-[[:space:]]*trigger: ]]; then
            current_trigger=$(echo "$line" | sed 's/.*trigger:\s*//' | sed 's/^["'"'"']//' | sed 's/["'"'"']$//')
        elif [[ "$line" =~ ^[[:space:]]*workflow: ]]; then
            current_workflow=$(echo "$line" | sed 's/.*workflow:\s*//' | sed 's/^["'"'"']//' | sed 's/["'"'"']$//')
        elif [[ "$line" =~ ^[[:space:]]*description: ]]; then
            current_description=$(echo "$line" | sed 's/.*description:\s*//' | sed 's/^["'"'"']//' | sed 's/["'"'"']$//')

            # Check if this menu item matches our trigger
            if [[ -n "$current_trigger" && -n "$current_workflow" ]]; then
                local patterns
                patterns=$(parse_trigger_patterns "$current_trigger")

                for p in $patterns; do
                    if [[ "$p" == "$trigger_lower" || "$p" == *"$trigger_lower"* || "$trigger_lower" == *"$p"* ]]; then
                        matched_workflow="$current_workflow"
                        matched_description="$current_description"
                        match_count=$((match_count + 1))
                        break
                    fi
                done
            fi

            # Reset for next item
            current_trigger=""
            current_workflow=""
            current_description=""
        fi
    done < "$agent_file"

    if [[ $match_count -gt 1 ]]; then
        echo "AMBIGUOUS"
        return 1
    elif [[ -n "$matched_workflow" ]]; then
        echo "$matched_workflow|$matched_description"
        return 0
    fi

    return 1
}

# Resolve {project-root} placeholder in workflow path
resolve_workflow_path() {
    local workflow_path="$1"
    local project_root="${BMAD_PROJECT_ROOT:-$(pwd)}"

    echo "$workflow_path" | sed "s|{project-root}|$project_root|g"
}

# List triggers for agents
cmd_triggers() {
    local agent="${1:-}"

    if [[ -n "$agent" ]]; then
        # Show specific agent's triggers
        local agent_file
        if ! agent_file=$(get_agent_file "$agent"); then
            error "Agent not found: $agent"
        fi

        local name icon title
        name=$(yaml_get "$agent_file" "name")
        icon=$(yaml_get "$agent_file" "icon")
        title=$(yaml_get "$agent_file" "title")

        echo -e "${CYAN}$icon $name ($title) - Triggers${NC}"
        echo ""

        # Parse and display menu items
        local in_menu=0
        local current_trigger=""
        local current_workflow=""
        local current_description=""

        while IFS= read -r line; do
            if [[ "$line" =~ ^[[:space:]]*menu: ]]; then
                in_menu=1
                continue
            fi

            if [[ $in_menu -eq 1 && "$line" =~ ^[^[:space:]] && -n "$line" ]]; then
                in_menu=0
            fi

            [[ $in_menu -eq 0 ]] && continue

            if [[ "$line" =~ ^[[:space:]]*-[[:space:]]*trigger: ]]; then
                current_trigger=$(echo "$line" | sed 's/.*trigger:\s*//' | sed 's/^["'"'"']//' | sed 's/["'"'"']$//')
            elif [[ "$line" =~ ^[[:space:]]*workflow: ]]; then
                current_workflow=$(echo "$line" | sed 's/.*workflow:\s*//' | sed 's/^["'"'"']//' | sed 's/["'"'"']$//')
            elif [[ "$line" =~ ^[[:space:]]*description: ]]; then
                current_description=$(echo "$line" | sed 's/.*description:\s*//' | sed 's/^["'"'"']//' | sed 's/["'"'"']$//')

                if [[ -n "$current_trigger" ]]; then
                    local patterns
                    patterns=$(parse_trigger_patterns "$current_trigger")
                    echo -e "  ${GREEN}${patterns// / | }${NC}"
                    echo "    $current_description"
                    echo -e "    ${BLUE}$current_workflow${NC}"
                    echo ""
                fi

                current_trigger=""
                current_workflow=""
                current_description=""
            fi
        done < "$agent_file"
    else
        # List all agents and their triggers
        echo -e "${CYAN}ðŸ“‹ BMAD Agent Triggers${NC}"
        echo ""
        printf "  %-20s %-15s %s\n" "AGENT" "NAME" "TRIGGERS"
        printf "  %-20s %-15s %s\n" "â”€â”€â”€â”€â”€" "â”€â”€â”€â”€" "â”€â”€â”€â”€â”€â”€â”€â”€"

        for f in "$BMAD_AGENTS_DIR"/*.agent.yaml; do
            [[ -f "$f" ]] || continue

            local agent_id name triggers_list
            agent_id=$(basename "$f" .agent.yaml)
            name=$(yaml_get "$f" "name")

            # Collect triggers
            triggers_list=""
            local in_menu=0
            while IFS= read -r line; do
                if [[ "$line" =~ ^[[:space:]]*menu: ]]; then
                    in_menu=1
                    continue
                fi
                if [[ $in_menu -eq 1 && "$line" =~ ^[^[:space:]] && -n "$line" ]]; then
                    in_menu=0
                fi
                [[ $in_menu -eq 0 ]] && continue

                if [[ "$line" =~ ^[[:space:]]*-[[:space:]]*trigger: ]]; then
                    local trigger
                    trigger=$(echo "$line" | sed 's/.*trigger:\s*//' | sed 's/^["'"'"']//' | sed 's/["'"'"']$//')
                    local patterns
                    patterns=$(parse_trigger_patterns "$trigger")
                    local first_pattern
                    first_pattern=$(echo "$patterns" | awk '{print $1}')
                    if [[ -n "$first_pattern" ]]; then
                        [[ -n "$triggers_list" ]] && triggers_list="$triggers_list, "
                        triggers_list="$triggers_list$first_pattern"
                    fi
                fi
            done < "$f"

            # Truncate if too long
            if [[ ${#triggers_list} -gt 40 ]]; then
                triggers_list="${triggers_list:0:37}..."
            fi

            printf "  %-20s %-15s %s\n" "$agent_id" "$name" "$triggers_list"
        done

        echo ""
        echo "  Run 'gt-bmad-workflow triggers <agent>' for detailed trigger info."
    fi
}

# Dispatch workflow by agent trigger
cmd_dispatch() {
    local agent="$1"
    local trigger="$2"
    local dry_run="${3:-}"

    if [[ -z "$agent" || -z "$trigger" ]]; then
        error "Usage: gt-bmad-workflow dispatch <agent> <trigger> [--dry-run]"
    fi

    # Find agent file
    local agent_file
    if ! agent_file=$(get_agent_file "$agent"); then
        error "Agent not found: $agent"
    fi

    local agent_name agent_icon agent_title
    agent_name=$(yaml_get "$agent_file" "name")
    agent_icon=$(yaml_get "$agent_file" "icon")
    agent_title=$(yaml_get "$agent_file" "title")

    # Match trigger
    local match_result
    if ! match_result=$(match_agent_trigger "$agent_file" "$trigger"); then
        if [[ "$match_result" == "AMBIGUOUS" ]]; then
            error "Ambiguous trigger '$trigger' - matches multiple menu items"
        else
            error "No matching trigger found for '$trigger' in agent '$agent'"
        fi
    fi

    local workflow_path workflow_desc
    workflow_path=$(echo "$match_result" | cut -d'|' -f1)
    workflow_desc=$(echo "$match_result" | cut -d'|' -f2-)

    # Resolve path
    local resolved_path
    resolved_path=$(resolve_workflow_path "$workflow_path")

    # Display info
    echo -e "${CYAN}ðŸ”„ Workflow Dispatch${NC}"
    echo ""
    echo "  Agent:    $agent_icon $agent_name ($agent_title)"
    echo "  Trigger:  $trigger"
    echo "  Workflow: $workflow_desc"
    echo "  Path:     $resolved_path"

    if [[ "$dry_run" == "--dry-run" ]]; then
        echo ""
        echo -e "${YELLOW}[dry-run]${NC} Would execute workflow"
        return 0
    fi

    # Check if workflow file exists
    if [[ ! -f "$resolved_path" ]]; then
        echo ""
        warn "Workflow file not found: $resolved_path"
        echo ""
        echo "The workflow file needs to be installed. Options:"
        echo "  1. Install BMAD in your project: npx bmad install"
        echo "  2. Set BMAD_PROJECT_ROOT to specify location"
        echo ""
        echo "Agent file: $agent_file"
        return 1
    fi

    # Execute workflow
    echo ""
    echo -e "${GREEN}â†’${NC} Executing workflow..."
    echo ""

    # Display workflow content
    echo -e "${BLUE}--- Workflow Content ---${NC}"
    cat "$resolved_path"
    echo -e "${BLUE}--- End Workflow ---${NC}"
    echo ""
    echo -e "${GREEN}âœ“${NC} Workflow loaded. Execute according to workflow instructions."
    echo ""
    echo -e "${CYAN}ðŸ“‹ Human Interaction Protocol${NC}"
    echo ""
    echo "  When you need human input (A/P/C menus, discovery questions):"
    echo ""
    echo "  1. For A/P/C menus:"
    echo "     gt-bmad ask --menu \"A|Advanced elicitation|P|Party mode|C|Continue\" \"Select option:\""
    echo ""
    echo "  2. For discovery questions:"
    echo "     gt-bmad ask \"What is the core problem we're solving?\""
    echo ""
    echo "  3. For numbered choices:"
    echo "     gt-bmad ask --choices \"1|User-selected|2|AI-recommended\" \"How to proceed?\""
    echo ""
    echo "  The polecat will block until the human responds. Human can answer via:"
    echo "  - Typing directly in this terminal"
    echo "  - Running: gt-bmad answer <question-id> <response>"
    echo ""
}

# Helper for interactive workflow - present standard A/P/C menu
cmd_apc_menu() {
    local context="${1:-content}"
    exec "$SCRIPT_DIR/../bin/gt-ask" \
        --menu "A|Advanced elicitation - dive deeper into $context|P|Party mode - bring in other agents|C|Continue to next step" \
        "What would you like to do?"
}

# Main dispatch
main() {
    if [[ $# -eq 0 ]]; then
        usage
        exit 0
    fi

    local cmd="$1"
    shift

    case "$cmd" in
        # Agent dispatch commands
        dispatch|run)
            cmd_dispatch "$@"
            ;;
        triggers)
            cmd_triggers "$@"
            ;;
        # Workflow management commands
        list)
            cmd_list "$@"
            ;;
        generate|gen)
            cmd_generate "$@"
            ;;
        start)
            cmd_start "$@"
            ;;
        auto-start|autostart)
            cmd_auto_start "$@"
            ;;
        status)
            cmd_status "$@"
            ;;
        step)
            cmd_step "$@"
            ;;
        close|done)
            cmd_close "$@"
            ;;
        # Runtime integration commands
        step-done)
            cmd_step_done "$@"
            ;;
        context)
            cmd_context "$@"
            ;;
        continue)
            cmd_continue "$@"
            ;;
        apc-menu|apc)
            cmd_apc_menu "$@"
            ;;
        help|--help|-h)
            usage
            exit 0
            ;;
        *)
            error "Unknown command: $cmd (try 'gt-bmad-workflow help')"
            ;;
    esac
}

main "$@"
